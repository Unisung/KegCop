==============================================

iDevice Serial Communication

iDevice 30 pin connector Communication
12 - Tx (transmit over serial) (dots on cable means TX)
13 - Rx (read over serial) (solid line on cable means RX)
1,11, 15 - Ground
23 - 5V Power
18 - 3.3V Power

External Accessory framework

Use a 1K resistor to step the 5V down to 3.3V for serial communication

==============================================

==============================================
Proof of Concept - Arduino - iDevice Communication
==============================================
iDevice has to send signal over serial com to Arduino that then sends signal to solenoid to open









==============================================
END - Proof of Concept - Arduino - iDevice Com
==============================================

==============================================
Building KegBot on iDevice (3GS)
==============================================

Dependices
- Python 2.7
- Django 1.4
- MySQL, Postgres, or SQLite
- Python-Imaging 1.7

-----
Instructions
-----
- Install the python-sqlite package


------
Notes
------
- python-sqlite - interfaces with an SQLite 2.x database - http://packages.debian.org/stable/python/python-sqlite

- to interface to SQLite 3, see the package python-pysqlite1.1 - http://packages.debian.org/stable/python/python-pysqlite2

- if using Python 2.5 and up, already have working version of pysqlite 2 bundled http://trac.edgewall.org/wiki/PySqlite






===============================================================================
Script - Copy app out of sandbox into /private/var/stash to get serial communication
===============================================================================

The script will first delete the old app, copy across the new one, then finally respiring so the new app can be used.

#———————-
# sandbox directory - /var/mobile/Applications/
echo "Product Name: ${PRODUCT_NAME}"
echo "Target Build Dir: ${TARGET_BUILD_DIR}"
#
ssh -T root@10.0.1.11 rm -rf /Applications/${WRAPPER_NAME}
echo "${WRAPPER_NAME} Removed"
#
echo "PWD: ${PWD}"
scp -r "${TARGET_BUILD_DIR}/${WRAPPER_NAME}" root@10.0.1.11:/Applications/
echo “Copy Complete”
#
ssh -T root@10.0.1.11 killall -HUP SpringBoard
echo "Respringing…"
#———————-

===========================================
Script - End
===========================================

======================================
Solenoid Wiring
=====================================
one more question how do i wire this into the kegboard shield? i mean i plug the AC 
               adapter into the wall, then hook the red wire and black wire to the arduino, then 
               run two wires from the arduino to solenoid
20:00 < geoffc> that's close, but you'll want to have the + wire into and out of kegboard relay. ( 
                one from the wall adapter and one to the valve).
20:00 < geoffc> and then a negative wire (black)  from the valve to the ac adapter



========================================
Serial port programming
========================================

int
read_port(void)
{
    int fd = open("/dev/ttyS0", O_RDONLY | O_NOCTTY);
    if (fd == -1)
    {
        /* Could not open the port. */
        perror("open_port: Unable to open /dev/ttyS0 - ");
    }

    char buffer[32];
    int n = read(fd, buffer, sizeof(buffer));
    if (n < 0)
        fputs("read failed!\n", stderr);
    return (fd);
}







========================================
Obsolete Code
========================================
   
            // KEYCHAIN - OBSOLETE
            //if ([anAccount.pin isEqualToString:_textFieldPin.text]){
              //  NSLog(@"Your pin is correct");
              
              
===========================================
Serial Port Programming
===========================================

/*
 * 'open_port()' - Open serial port on dock connector pins 13RX / 12TX
 *
 * Returns the file descriptor on success or -1 on error.
 */

int openPort(void)
{
    int fd = -1; /* File descriptor for the port */
    
    struct termios options; 
    
    printf("Trying to open port!\n");
    
    fd = open("/dev/tty.iap", O_RDWR | O_NOCTTY | O_NDELAY); // O_NOCTTY - don't be controlling terminal, O_NODELAY don't care about DCD signal state
    if ( fd == -1)
    {
        // couldn't open the port
        
        perror("open_port: Unable to open /dev/tty.iap - ");
    }
    else
        fcntl(fd, F_SETFL, 0);
    
    tcgetattr(fd, &options); // get current options for the port
    
    // set the baud rate
    cfsetispeed(&options, B2400);
    cfsetospeed(&options, B2400);
    
    // enable the receiver and set local mode
    options.c_cflag |= (CLOCAL | CREAD);
    
    // set the new options for the port
    tcsetattr(fd, TCSANOW, &options);
    
    return (fd);

}

=============================================
Serial Port Programming
=============================================

char *portname = "/dev/tty.iap";
char buf[256];

int main(int argc, char *argv[])
{

    int fd;

    // Open the file descriptor in non-blocking mode
    fd = open(portname, O_RDWR | O_NOCTTY);

    // set up the control structure
    struct termios toptions;
        
    // get current set options for the tty
    tcgetattr(fd, &toptions);

    // set custom options
    
    // set baud rate
    cfsetispeed(&toptions, B2400);
    cfsetospeed(&toptions, B2400);
    
    // 8 bits, no parity no stop bits
    toptions.c_cflag &= ~PARENB;
    toptions.c_cflag &= ~CSTOPB;
    toptions.c_cflag &= ~CSIZE;
    toptions.c_cflag |= CS8;
    
    // no hardware flow control
    toptions.c_cflag &= ~CRTSCTS;
    
    // enable receiver
    toptions.c_cflag |= CREAD | CLOCAL;
    	 
    // disable input/output flow control, disable restart chars
    toptions.c_iflag &= ~(IXON | IXOFF | IXANY);
    	 
    // disable canonical input, disable echo,
    // disable visually erase chars,
    // disable terminal-generated signals */
    toptions.c_iflag &= ~(ICANON | ECHO | ECHOE | ISIG);
    	 
    // disable output processing
    toptions.c_oflag &= ~OPOST;
    	 
    // wait for 24 characters to come in before read returns
    toptions.c_cc[VMIN] = 12;
    	 
    // no minimum time to wait before read returns
    toptions.c_cc[VTIME] = 0;
    	 
    // commit the options */
    tcsetattr(fd, TCSANOW, &toptions);
    	 
    // Wait for the Arduino to reset */
    usleep(1000*1000);
    	 
    // Flush anything already in the serial buffer */
    tcflush(fd, TCIFLUSH);
    	 
    // read up to 128 bytes from the fd */
    int n = read(fd, buf, 128);
    	 
    // print how many bytes read */
    printf("%i bytes got read...\n", n);
    	 
    // print what's in the buffer */
    printf("Buffer contains...\n%s\n", buf);
    	 
    return 0;
}


15SEP12
- Added Serial.h, Serial.c, KBKegboard.h, KBKegboard.m, KBKegboardMessage.h, KBKegboardMessage.m, crc16ccitt.c, crc16ccitt.h




==============================================================

KegPad Serial Com
==============================================================
------------------------
Serial.c
------------------------

//
//  Serial.c
//  KegCop
//
//  This file was originally created for the KegPad project.
//  Created by capin on 8/2/12.
//

#include <stdio.h>   /* Standard input/output definitions */
#include <stdlib.h>
#include <string.h>  /* String function definitions */
#include <unistd.h>  /* UNIX standard function definitions */
#include <fcntl.h>   /* File control definitions */
#include <errno.h>   /* Error number definitions */
#include <termios.h> /* POSIX terminal control definitions */
#include <sys/ioctl.h>

/*! openPort(portName, baudRate) - Open serial port
 Example:
 NSInteger fileDescriptor = openPort("/dev/tty.iap", 9600)
 write(fileDescriptor, "hello world", 12)
 */

int openPort(char *portName, int baudRate) {
    int fileDescriptor;
    struct termios options;
    printf("Trying to open port!\n");
    fileDescriptor = open(portName, O_RDWR | O_NOCTTY | O_NONBLOCK);
    if (fileDescriptor == -1) {
        char *errorString = malloc(100);
        sprintf(errorString, "Open_port: Unable to open port %s", portName);
        perror(errorString);
        free(errorString);
    } else {
        fcntl(fileDescriptor, F_SETFL, 0);
    }
    
    // Get the current options for the port...
    tcgetattr(fileDescriptor, &options);
    
    // Set baud rate
    cfsetispeed(&options, baudRate);
    cfsetospeed(&options, baudRate);
    
    // Enable the receiver and set local mode...
    options.c_cflag |= (CLOCAL | CREAD);
    
    // Set the new options for the port...
    tcsetattr(fileDescriptor, TCSANOW, &options);
    
    return (fileDescriptor);
}

// For non-blocking reads, collects data until [length] bytes are collected
void sleeperRead(int fileDescriptor, char *data, int length) {
    int index = 0;
    while (index < length) {
        int bytesRead = read(fileDescriptor, &data[index], length - index);
        if (bytesRead == 0) usleep(10000); // Sleep 10ms
        index += bytesRead;
    }
    /* Uncomment for debugging
     for (int i = 0; i < length; i++) {
     printf("%2X %c\n", data[i], data[i]);
     }
     */
}

------------------------------------
Serial.h
------------------------------------

//
//  Serial.h
//  KegCop
//
//  Created by capin on 8/2/12.
//


NSInteger openPort(char *portName, NSInteger baudRate);

void sleeperRead(int fileDescriptor, char *data, int length);

// open port first, then call sleeperRead


-----------------------------------------
ViewControllerSerialConsole.m
-----------------------------------------

- (void)viewDidLoad
{
    [super viewDidLoad];
	// Do any additional setup after loading the view.
    
    // open the serial port - /dev/tty.ipa
    
    // open port
    
    // char = read 1 char
    
    // while ( char ! NL )
     // {
            // append char to end of string
    
            // read next character
     // }
    
    // if string not valid
    
    
    // -------------------------
    
    // while
    
    // read char
    
    // write to console / textview
    
    // end while
       
    //char somechar[8];
    
    // print the serial data to the console
    //NSLog(@"The serial data is %d",serial);
    
    // read data coming across the serial port
    //read(serial,&somechar[0],1);
    
    // print the serial data in the textview
    //_serialView.text = [NSString stringWithFormat:@"%i",serial];
    
    
    // span a new thread for the while loop
    
    // reading off the serial port is an event
    
    FILE *serial_in;
    
    char line_buffer[1000];
    
    // int lineBufferUsed;
    int portnum;
    
    NSLog(@"got to A");
    
    portnum = openPort("/dev/tty.iap",9600);
    
    NSLog(@"got to B");
    
    
    serial_in = fdopen(portnum, "r"); // r = read
    
    NSLog(@"got to C");
    
    while (1) {
        
        NSLog(@"got to D");
        
         fgets (line_buffer, 1000, serial_in); // get up too 1000bytes but stop at \n
        
        NSLog(@"got to E %s",line_buffer);
        
        // print line to textview
       // _serialView.text = [NSString stringWithFormat:@"%s",line_buffer];
        
        NSLog(@"got to F");
    }
    
    
    // main thread is trapped in while loop
    
    
    
}


================================================
Serial Example
================================================
/*
static int OpenSerialPort()
{
    int fileDescriptor = -1;
    int handshake;
    struct termios options;

    fileDescriptor = opne("dev/tty.iap", O_RDWR | O_NOCTTY  | O_NONBLOCK);
    options = gOriginalTTYAttrs;
    printf("Current input baud rate is %d\n", (int) cfgetispeed(&options));
    printf("Current ouput baud rate is %d\n", (int) cfgetospeed(&options));
    cfmakeraw(&options);
    options.c_cc[VMIN] = 1;
    options.c_cc[VTIME] = 10;
    cfsetspeed(&options, B9600);
    options.c_cflag |= (CS8);
    printf("input baud rate changed to %d\n", (int) cfgetispeed(&options));
    printf("Output baud rate changed to %d\n", (int) cfgetospeed(&options));
       
    if (tcsetattr(fileDescriptor, TCSANOW, &options) == -1)
    {
           printf("Error setting tty attributes %s - %s(%d).\n", "/dev/tty.iap", strerror(errno), errno);
    }
    // Success
    return fileDescriptor;
       
    }

*/



----------------------------------------------------------


- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string {

NSLog(@"Range: %@", NSStringFromRange(range));
return ( range.location < 10 );

}


=================================================
waiting for user response
=================================================

bool happeningNow = false;

while (!happeningNow)
{
   if(someConditionisMet)
   {
        happeningNow = true;

    }

   if(happeningNow)
   {
      // whatever
    }

}



UIAlertView *alert = [[UIAlertView alloc]initWithTitle:@"title" message:@"szMsg" delegate:self cancelButtonTitle:@"Ok" otherButtonTitles:@"download"];
        [alert show];
        [alert release];

- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex
{
    if (buttonIndex == 0)
    {
        //Code for OK button
    }
    if (buttonIndex == 1)
    {
        //Code for download button
    }
}

-(void)alertView:(UIAlertView *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex {
    if(actionSheet== alertLogout) {//alertLogout
        if (buttonIndex == 0){

        }else if(buttonIndex==1){

        }
    }else if (actionSheet==alertComment) {//alertComment
        if (buttonIndex==0) {

        }
    }
}



========================================================
Using GCD in an Application
========================================================

1. Create a new queue

2. Add blocks to the queue

dispatch_queue_create

Example:

dispatch_queue_t myQueue =
dispatch_queue_create("myQueueName", NULL);

dispatch_async(myQueue, ^{ [self longRunningOperation]; } );  // this is the code that is executed on the secondary thread

Note: UI updates should only happen on the main thread.


========================================================================
KeychainHelper - Class - .h
========================================================================

//
//  KeychainHelper.h
//  KegCop
//
//  Created by capin on 6/8/12.
//


@interface KeychainHelper : NSObject

+ (NSString*)getPasswordForKey:(NSString*)aKey;
+ (void)setPassword:(NSString*)aPassword forKey:(NSString*)aKey;
+ (void)removePasswordForKey:(NSString*)aKey;

@end

========================================================================

KeychainHelper - Class - .m
========================================================================

//
//  KeychainHelper.m
//  KegCop
//
//  Created by capin on 6/8/12.
//

#import "KeychainHelper.h"
#import <Security/Security.h>

@interface KeychainHelper ()
+ (NSMutableDictionary*)dictionaryForKey:(NSString*)aKey;
@end

@implementation KeychainHelper

static const NSString *SERVICE_NAME = @"com.chrisrjones.kegcop";

+ (NSMutableDictionary*)dictionaryForKey:(NSString*)aKey
{
    NSData *encodedKey = [aKey dataUsingEncoding:NSUTF8StringEncoding];
    
    NSMutableDictionary *searchDictionary = [NSMutableDictionary dictionary];
    
    [searchDictionary setObject:(__bridge id)kSecClassGenericPassword forKey:(__bridge id)kSecClass];
    [searchDictionary setObject:encodedKey forKey:(__bridge id)kSecAttrGeneric];
    [searchDictionary setObject:encodedKey forKey:(__bridge id)kSecAttrAccount];
    [searchDictionary setObject:SERVICE_NAME forKey:(__bridge id)kSecAttrService];
    
    return searchDictionary;
}

+ (NSString*)getPasswordForKey:(NSString*)aKey
{
    NSString *password = nil;
    
    NSMutableDictionary *searchDictionary = [self dictionaryForKey:aKey];
    
    [searchDictionary setObject:(__bridge id)kSecMatchLimitOne forKey:(__bridge id)kSecMatchLimit];
    [searchDictionary setObject:(id)kCFBooleanTrue forKey:(__bridge id)kSecReturnData];
    
    /*
    NSData *result = nil;
    SecItemCopyMatching((__bridge CFDictionaryRef)searchDictionary, (CFTypeRef *)&result);
    
    if (result)
    {
        password = [[NSString alloc] initWithData:result encoding:NSUTF8StringEncoding];
        
    }
    */
    
    CFTypeRef result = NULL;
    BOOL statusCode = SecItemCopyMatching((__bridge CFDictionaryRef)searchDictionary, &result);
    if (statusCode == errSecSuccess) {
        NSData *resultData = CFBridgingRelease(result);
        password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];

    }
    
    return password;
}

+ (void)removePasswordForKey:(NSString*)aKey
{
    NSMutableDictionary *keyDictionary = [self dictionaryForKey:aKey];
    SecItemDelete((__bridge CFDictionaryRef)keyDictionary);
}

+ (void)setPassword:(NSString*)aPassword forKey:(NSString*)aKey
{
    [KeychainHelper removePasswordForKey:aKey];
    
    NSData *encodedPassword = [aPassword dataUsingEncoding:NSUTF8StringEncoding];
    
    NSMutableDictionary *keyDictionary = [self dictionaryForKey:aKey];
    [keyDictionary setObject:encodedPassword forKey:(__bridge id)kSecValueData];
    SecItemAdd((__bridge CFDictionaryRef)keyDictionary, nil);
}
@end

========================================================================


//
//  Account.m
//  KegCop
//
//  Created by capin on 6/8/12.
//

#import "Account.h"
#import "KeychainHelper.h"


@implementation Account

- (NSString*)password 
{
    if (self.username)
        return [KeychainHelper getPasswordForKey:self.username];
    return nil;
}

-(NSString*)getPasswordFromKeychain
{
    if (self.username)
        return [KeychainHelper getPasswordForKey:self.username];
    return nil;
}

- (void)setPassword:(NSString*)aPassword 
{
    if (self.username) [KeychainHelper setPassword:aPassword forKey:self.username];
    
    
}
- (void)prepareForDeletion
{
    if (self.username) [KeychainHelper removePasswordForKey:self.username];
}
@end































