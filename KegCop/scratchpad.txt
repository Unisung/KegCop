- (void) textFieldDidBeginEditing:(UITextField *)textField
{
    [textField setInputAccessoryView:keyboardToolbar];
    for (int i=0; i<[textFields count]; i++) {
        if ([textFields objectAtIndex:i]==textField) {
            if (i==[textFields count]-1) {
                toolbarActionButton.title = @"Done";
                [toolbarActionButton setStyle:UIBarButtonItemStyleDone];
            }
           // [self. scrollToRowAtIndexPath: [NSIndexPath indexPathForRow:i inSection:0]
                           //       atScrollPosition:UITableViewScrollPositionMiddle animated:YES];
        }
    }
}

- (IBAction) closedKeyboard{
    for (UITextField *t in textFields){
        if ([t isEditing]) {
            [t resignFirstResponder];
            break;
        }
    }
}

- (IBAction) nextField{
    for (int i=0; i<[textFields count]; i++) {
        
        if ([[textFields objectAtIndex:i] isEditing] && i!=[textFields count]-1) {
            [[textFields objectAtIndex:i+1] becomeFirstResponder];
            if (i+1==[textFields count]-1) {
                [toolbarActionButton setTitle:@"Done"];
                [toolbarActionButton setStyle:UIBarButtonItemStyleDone];
            }else {
                [toolbarActionButton setTitle:@"Close"];
                [toolbarActionButton setStyle:UIBarButtonItemStyleBordered];
            }
            
            [self.uiviewcontroller scrollToRowAtIndexPath:[NSIndexPath indexPathForRow:i+1 inSection:0] atScrollPosition:UITableViewScrollPositionMiddle animated:YES];
            
            break;
        }
    }

}

- (IBAction) prevField{
    for (int i=0; i<[textFields count]; i++) {
        if ([[textFields objectAtIndex:i] isEditing] && i!=0) {
            [[textFields objectAtIndex:i-1] becomeFirstResponder];
            [toolbarActionButton setTitle:@"Close"];
            //[self.tableView scrollToRowAtIndexPath:[NSIndexPath indexPathForRow:i-1 inSection:0] atScrollPosition:UITableViewScrollPositionMiddle animated:YES];
            [toolbarActionButton setStyle:UIBarButtonItemStyleBordered];
            break;
        }
    }
}





















// method - notifications - keyboard

- (void) viewWillAppear: (BOOL)animated {
    // registers the notifications for keyboard
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardDidShow:) name:UIKeyboardDidShowNotification object:self.view.window];
    
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardDidHide:) name:UIKeyboardDidHideNotification object:nil];
}

-(void) viewWillDisappear:(BOOL)animated {
    // removes the notifications for keyboard
    [[NSNotificationCenter defaultCenter] removeObserver:self name:UIKeyboardWillShowNotification object:nil];
    
    [[NSNotificationCenter defaultCenter] removeObserver:self name:UIKeyboardWillHideNotification object:nil];
}

- (void) keyboardDidShow:(NSNotification *) notification {
    if (keyboardIsShown) return;
    
    NSDictionary* info = [notification userInfo];
    
    // obtain the size of the keyboard
    NSValue *aValue = [info objectForKey:UIKeyboardBoundsUserInfoKey];
    CGSize keyboardsize = [aValue CGRectValue].size;
    
    // resize the sccroll view (with keyboard)
    CGRect viewFrame = [_createScroller frame];
    viewFrame.size.height -= keyboardsize.height;
    _createScroller.frame = viewFrame;
    
    // scroll to the current text field
    CGRect textFieldRect = [currentTextField frame];
    [_createScroller scrollRectToVisible:textFieldRect animated:YES];
    
    keyboardIsShown = YES;
}

- (void) keyboardDidHide:(NSNotification *) notification {
    NSDictionary* info = [notification userInfo];
    
    // obtain size of keyboard
    NSValue* aValue = [info objectForKey:UIKeyboardBoundsUserInfoKey];
    CGSize keyboardSize = [aValue CGRectValue].size;
    
    // resize the scroll view back to the original size
    CGRect viewFrame = [_createScroller frame];
    viewFrame.size.height += keyboardSize.height;
    _createScroller.frame = viewFrame;
    
    keyboardIsShown = NO;
    
}




































Hey Chris, I'm back.

I saw your question at stackoverflow, but I don't think I understand correctly. You should be able to create a new instance of Account doing something like:

Account *account = [NSEntityDescription insertNewObjectForEntityForName:@"Account" inManagedObjectContext:yourContextVariable];

By the time you do that, the entry has already been created in your managed object context, so to set the values of the account you would just fill its properties, like:

account.email = some string

Your changes in the managed object context are not "flushed" so to speak until you call [yourContextVariable save] though.

Not sure if that's where you were stuck at.

   
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    // CORE DATA - APPLE EXAMPLE
    NSManagedObjectContext *context = _managedObjectContext;
    
    NSEntityDescription *entity = [NSEntityDescription entityForName:@"Account" inManagedObjectContext:context];
    
    NSFetchRequest *request = [[NSFetchRequest alloc] init];
    
    [request setEntity:entity];
    
    [request setResultType:NSDictionaryResultType];
    
    [request setReturnsDistinctResults:YES];
    
    [request setPropertiesToFetch :[NSArray arrayWithObject:@"username"]];
    
    // Execute the fetch.
    
    NSError *error;
    
    id requestedValue = nil;
    
    NSArray *objects = [_managedObjectContext executeFetchRequest:request error:&error];
    
    if (objects == nil) {
        
        NSLog(@"objects are set to nil.");
    }
   
   
   
   
   
   
   
   
   
   
   
   // NSError *error = nil;
    //NSArray *users = [_managedObjectContext executeFetchRequest:fetchRequest error:&error];
    
    
    
    
    // Set up a predicate (or search criteria) for checking the username
    //NSPredicate *pred = [NSPredicate predicateWithFormat:@"(username == %@)", [_textFieldUsername text]];
    
    // check if _textFieldPin matches pin stored in keychain
   
    // if ([pin = *password]);
                          
                          
    // - (NSString*)password 
    
    
    /*
    NSString *inputKey = _textFieldPin.text;
    NSString *password = [KeychainHelper getPasswordForKey:inputKey];
    if ([password isEqualToString:inputKey]) {
        NSLog(@"password matches stored pin");
    }
    else {
        [_wrongUserPin setHidden:NO];
    }
    */
    
    //+ (NSString*)getPasswordForKey:(NSString*)aKey;
    
    
    // Actually run the query in Core Data and return the count of found users with these details
    // Obviously if it found ANY then we got the username right!
    
    
    
    // check if username and pin are a match
    
    /*
    // check if username = root
    NSString *string = @"root";
    // get the value inputted in textFieldUsername and put it in a string object.
    NSString *tf_Username = [_textFieldUsername text ];
    
    // compare "root" with tf_Username
    if ([string isEqualToString: tf_Username])  {
        // load root Welcome Screen
        [self performSegueWithIdentifier:@"AdminSegue" sender:sender];
    }
    else {
        // load user Welcome screen
        [self performSegueWithIdentifier:@"UserSegue" sender: sender];
    }
    */
    
    
     /*
    // fetch request
    NSFetchRequest *fetchRequest = [[NSFetchRequest alloc] init];
    // fetchRequest.entity = [NSEntityDescription entityForName:@"Account" inManagedObjectContext:_managedObjectContext];
    fetchRequest.predicate = [NSPredicate predicateWithFormat:@"self.name == %@", inputUser];
    fetchRequest.fetchLimit = 1;
     */
     
     
     
     // APPLE EXAMPLE
     
     
     NSManagedObjectContext *context = _managedObjectContext;
    
    NSEntityDescription *entity = [NSEntityDescription entityForName:@"Account" inManagedObjectContext:context];
    
    NSFetchRequest *request = [[NSFetchRequest alloc]init];
    
    [request setEntity:entity];
    
    [request setResultType:NSDictionaryResultType];
    
    [request setReturnsDistinctResults:YES];
    
    [request setPropertiesToFetch :[NSArray arrayWithObject:@"username"]];
    
    // Execute the fetch.
    
    NSError *error;
    
    id requestedValue = nil;
    
    NSArray *objects = [_managedObjectContext executeFetchRequest:request error:&error];
    
    
    
